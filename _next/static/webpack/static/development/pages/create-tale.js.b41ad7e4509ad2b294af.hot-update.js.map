{"version":3,"file":"static/webpack/static\\development\\pages\\create-tale.js.b41ad7e4509ad2b294af.hot-update.js","sources":["webpack:///./src/redux/reducers/wipTaleReducer.js"],"sourcesContent":["/**\r\n * This is hold and manage the state of the current WIP Tale\r\n * id: StoryID\r\n * start: Start Storylet ID\r\n */\r\nimport { make3Figure } from '../../utils/util'\r\nimport { \r\n    TALE_CREATE, \r\n    TALE_SET_AS_WIP,\r\n    TALE_UPDATE_INFO,\r\n    TALE_STATE_CLEANUP,\r\n    STORYLET_CREATE,\r\n    STORYLET_DELETE,\r\n    STORYLET_UPDATE_FIELD,\r\n    STORYLET_UPDATE_ALL_TEXT,\r\n    STORYBOARD_ADD_SINGLE,\r\n    STORYBOARD_INSERT_AT,\r\n    STORYBOARD_SELECT_CHOICE,\r\n    CHOICE_CREATE,\r\n    CHOICE_DELETE,\r\n    CHOICE_UPDATE_TEXT,\r\n    ADD_CID_TO_STID\r\n} from '../actionTypes'\r\n\r\nconst START_ST_ID = 'ST000' // BY MY STRICTEST CONVENTION \r\n\r\nconst getInitTaleState = () => ({\r\n    id: null,\r\n    start: null,\r\n    info: {\r\n        name: '',\r\n        description: '',\r\n        genre: 'Other',\r\n        lang: 'English',\r\n        tags: '',\r\n        authorEmail: '',\r\n        originalAuthor: '',\r\n        storyUrl: '',           // The PKey\r\n        desiredUrl: '',         // For local modification only, until storyUrl is got from Server on 1st Online Save\r\n        imgUrl: ''\r\n    },\r\n    idCounter: 0,\r\n    storylets: {},\r\n    choices: {},\r\n    storyboard: []  // sbI = { stID, selectedCID }  StoryBoardItems[]\r\n})\r\n\r\nconst createStorylet = st => {\r\n    st = st || {}\r\n    return {\r\n        id: st.id,\r\n        title: st.title || '',\r\n        text: st.text || '',\r\n        choices: st.choices || [] // This will hold only Choice IDs\r\n    }\r\n}\r\n\r\nconst createChoice = c => {\r\n    c = c || {}\r\n    return {\r\n        id: c.id,\r\n        text: c.text || '',\r\n        next: c.next || null\r\n    }\r\n}\r\n\r\nconst wipTaleReducer = (state=getInitTaleState(), action) => {\r\n    switch (action.type) {\r\n\r\n        /**\r\n         * Create a new Tale, START Storylet ID will always be \"st0\"\r\n         */\r\n        case TALE_CREATE: {\r\n            const storyID = 'R' + (new Date()).getTime() + Math.random().toString().replace('.','') // required for local-file-naming-collision-avoid etc\r\n            const newST = createStorylet({id: START_ST_ID})\r\n            let wipTale = {\r\n                ...state,\r\n                id: storyID,\r\n                start: START_ST_ID,\r\n                storylets: { \r\n                    [START_ST_ID]: newST\r\n                },\r\n                storyboard: [{stID: START_ST_ID}]\r\n            }\r\n            return wipTale\r\n        }\r\n\r\n        /**\r\n         * To work on an existing Tale, we need to set it as WIP Tale\r\n         */\r\n        case TALE_SET_AS_WIP: {\r\n            return {\r\n                ...action.payload,\r\n                storyboard: [{stID: START_ST_ID}]\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Update the \"info\" object of Tale, while typing in text fields \r\n         */\r\n        case TALE_UPDATE_INFO: {\r\n            return {\r\n                ...state,\r\n                info: action.payload\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Before leaving the Tale creation / edit page, it's good\r\n         * to reset the state\r\n         */\r\n        case TALE_STATE_CLEANUP: {\r\n            return getInitTaleState()\r\n        }\r\n\r\n        /**\r\n         * If already exists a storylet with STID, do nothing\r\n         * Else create one\r\n         */\r\n        case STORYLET_CREATE: {\r\n            const stID = action.payload.stID\r\n            if (state.storylets[stID]) {\r\n                return state\r\n            }\r\n            else {\r\n                const newST = createStorylet({id: stID})\r\n                return {\r\n                    ...state,\r\n                    idCounter: state.idCounter + 1,\r\n                    storylets: {\r\n                        ...state.storylets, \r\n                        [stID]: newST\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Delete the storylet of given stID as payload\r\n         * Delete all its choices\r\n         * Loop thru all storylets and delete all choices pointing to this one\r\n         * \r\n         * So basically, when we delete a storylet, we also delete all \r\n         * incoming and outgoing connectors (choice)\r\n         * i.e. deleting 1 storylet and lots of choices\r\n         */\r\n        case STORYLET_DELETE: {\r\n            let stID = action.payload\r\n            let st = state.storylets[stID]\r\n            let storylets = {...state.storylets}\r\n            let choices = {...state.choices}\r\n            // Delete all outgoing choices\r\n            for(let cID of st.choices) {\r\n                delete choices[cID]\r\n            }\r\n\r\n            // Now loop thru all the storylets, except this one\r\n            // And delete choices which point to this storylet\r\n            for(let id in storylets) {\r\n                if (id === stID) continue\r\n                storylets[id].choices = storylets[id].choices.filter(cID => {\r\n                    let ch = choices[cID]\r\n                    if(ch.next === stID) {\r\n                        delete choices[cID]\r\n                        return false\r\n                    }\r\n                    return true\r\n                })\r\n            }\r\n\r\n            // Finally delete this ST\r\n            delete storylets[stID]\r\n\r\n            let newState = {\r\n                ...state,\r\n                storylets,\r\n                choices\r\n            }\r\n            // console.log(newState)\r\n            return newState\r\n        }\r\n\r\n        /**\r\n         * Update the given storylet field of given STID as typed\r\n         */\r\n        case STORYLET_UPDATE_FIELD: {\r\n            const {stID, fieldName, value} = action.payload\r\n            const newST = {...state.storylets[stID]}\r\n            newST[fieldName] = value\r\n            return {\r\n                ...state,\r\n                storylets: {\r\n                    ...state.storylets,\r\n                    [stID]: newST\r\n                }\r\n            }\r\n        }\r\n\r\n        case STORYLET_UPDATE_ALL_TEXT: {\r\n            const { stID, title, text } = action.payload\r\n            const newST = {\r\n                ...state.storylets[stID],\r\n                title, text\r\n            }\r\n            return {\r\n                ...state,\r\n                storylets: {\r\n                    ...state.storylets,\r\n                    [stID]: newST\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * ADD a single Storyboard Item to Storyboard array\r\n         * Each Storyboard Item will be an object with STID, selectedCID (optional) etc\r\n         */\r\n        case STORYBOARD_ADD_SINGLE: {\r\n            return {\r\n                ...state,\r\n                storyboard: [...state.storyboard, {stID: action.payload.stID}]\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Add s SBI to a particular spot of SB\r\n         * If isRemoveOnly=true, that means user has deselected a Choice checkbox \r\n         * but nothing is selected\r\n         */\r\n        case STORYBOARD_INSERT_AT: {\r\n            const {sbI, nextStID, isRemoveOnly} = action.payload\r\n            let newSB = [...state.storyboard]\r\n            newSB = newSB.slice(0, sbI+1)\r\n            if (!isRemoveOnly) {\r\n                newSB.push({stID: nextStID})\r\n            }            \r\n            return {\r\n                ...state,\r\n                storyboard: newSB\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Select a particular Choice of a Storylet, means for that particular\r\n         * SBI we need to mark the CID as selected\r\n         */\r\n        case STORYBOARD_SELECT_CHOICE: {\r\n            const {sbI, cID} = action.payload\r\n            let newSB = [...state.storyboard]\r\n            newSB[sbI] = {\r\n                ...newSB[sbI],\r\n                selectedCID: cID\r\n            }\r\n            return {\r\n                ...state,\r\n                storyboard: newSB\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Create a new choice with the given data,\r\n         * Parameters in action.payload contains\r\n         * fromStID { mandatory }\r\n         * toStID { optional }\r\n         * text { optional }\r\n         */\r\n        case CHOICE_CREATE: {\r\n            let {fromStID, toStID, text} = action.payload\r\n            let fromST = {...state.storylets[fromStID]}\r\n            let idCounter = state.idCounter\r\n\r\n            // if toStID was not provided, create it\r\n            toStID = toStID || ('S' + make3Figure(++idCounter) )\r\n\r\n            // if toST does not exist create it\r\n            let toST = state.storylets[toStID] ? {...state.storylets[toStID]} : createStorylet({id: toStID})\r\n\r\n            // Now create the Choice\r\n            let cID = 'C' + make3Figure(++idCounter)\r\n            const newChoice = createChoice({id: cID, next: toStID, text})\r\n            fromST.choices = [...fromST.choices, cID]\r\n\r\n            return {\r\n                ...state,\r\n                idCounter: idCounter,\r\n                choices: {\r\n                    ...state.choices,\r\n                    [cID]: newChoice\r\n                },\r\n                storylets: {\r\n                    ...state.storylets,\r\n                    [toStID]: toST,\r\n                    [fromStID]: fromST\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Update the given choice text as typed\r\n         */\r\n        case CHOICE_UPDATE_TEXT: {\r\n            const {cID, value} = action.payload\r\n            const newChoice = {...state.choices[cID]}\r\n            newChoice.text = value\r\n            return {\r\n                ...state,\r\n                choices: {\r\n                    ...state.choices,\r\n                    [cID]: newChoice\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * CHOICE_DELETE => delete a choice of given ID\r\n         */\r\n        case CHOICE_DELETE: {\r\n            const cID = action.payload\r\n            let choices = {...state.choices}\r\n            // Go thru all the storylets\r\n            // And delete this cID from whoever has this choice\r\n            // Note: each choice is unique, one to one connector\r\n            // i.e. one choice belongs to 1 storylet only\r\n            // and it points to only 1 storylet with its next\r\n            let st;\r\n            for(let id in state.storylets) {\r\n                if(state.storylets[id].choices.indexOf(cID) > -1) {\r\n                    st = {...state.storylets[id]}\r\n                    break\r\n                }\r\n            }\r\n            // remove this cID from its parent st\r\n            st.choices = [...st.choices]\r\n            st.choices.splice(st.choices.indexOf(cID), 1)\r\n\r\n            // now delete this choice\r\n            delete choices[cID]\r\n\r\n            return {\r\n                ...state,\r\n                storylets: {\r\n                    ...state.storylets,\r\n                    [st.id]: st\r\n                },\r\n                choices\r\n            }\r\n\r\n        }\r\n        \r\n        /**\r\n         * Add the given choice to the given Storylet's choices array\r\n         */\r\n        case ADD_CID_TO_STID: {\r\n            const {stID, cID} = action.payload\r\n            const newST = {...state.storylets[stID]}\r\n            newST.choices = [...newST.choices, cID]\r\n            return {\r\n                ...state,\r\n                storylets: {\r\n                    ...state.storylets,\r\n                    [stID]: newST\r\n                }\r\n            }\r\n        }\r\n\r\n        default: {\r\n            return state\r\n        }\r\n    }\r\n}\r\n\r\nexport default wipTaleReducer"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAKA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAVA;AAYA;AACA;AACA;AACA;AACA;AAnBA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAEA;;;AAGA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AADA;AAGA;AAAA;AAAA;AAPA;AACA;AAQA;AACA;AACA;AACA;;;;AAGA;AAAA;AACA;AAEA;AAAA;AAAA;AAFA;AAIA;AACA;AACA;;;;AAGA;AAAA;AACA;AAEA;AAFA;AAIA;AACA;AACA;;;;;AAIA;AAAA;AACA;AACA;AACA;AACA;;;;;AAIA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAFA;AAHA;AAQA;AACA;AACA;AACA;;;;;;;;;;AASA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAHA;AACA;AACA;AAIA;AACA;AACA;AACA;;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAEA;AAFA;AAFA;AAOA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAFA;AACA;AAGA;AAEA;AAEA;AAFA;AAFA;AAOA;AACA;AACA;;;;;AAIA;AAAA;AACA;AAEA;AAAA;AAAA;AAFA;AAIA;AACA;AACA;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAFA;AAIA;AACA;AACA;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAFA;AAIA;AAEA;AAFA;AAIA;AACA;AACA;;;;;;;;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAEA;AAFA;AAIA;AAEA;AACA;AAHA;AAPA;AAaA;AACA;AACA;;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAEA;AAFA;AAFA;AAOA;AACA;AACA;;;;AAGA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAFA;AAIA;AANA;AASA;AACA;AACA;;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAEA;AAFA;AAFA;AAOA;AACA;AACA;AAAA;AACA;AACA;AA5SA;AA8SA;AACA;AACA;;;;A","sourceRoot":""}